/*
  GASM

  Assembler for the GVM.

  GASM takes two arguments: an input filename and an output filename.

  The input file must conform to the GASM language.

  The output file is the generated bytecode that can be sent as input to the GVM.

  If output filename is ommitted, will use input filename with a ".b" extension.
*/

#include "gvm.hpp"

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <cstring>

// opcode string --> pair< opcode code, opcode num-operands  >
std::map<std::string, std::pair<uint8_t, uint8_t>> opcodes = {
   {"NOP", {OP_NOP,0}},
   {"TERM", {OP_TERM,0}},
   {"SET", {OP_SET,2}},
   {"JMP", {OP_JMP,1}},   // labelref
   {"ADD", {OP_ADD,2}},
   {"SUB", {OP_SUB,2}},
   {"MUL", {OP_MUL,2}},
   {"DIV", {OP_DIV,2}},
   {"MOD", {OP_MOD,2}},
   {"OR", {OP_OR,2}},
   {"AND", {OP_AND,2}},
   {"XOR", {OP_XOR,2}},
   {"NOT", {OP_NOT,1}},
   {"SHL", {OP_SHL,2}},
   {"SHR", {OP_SHR,2}},
   {"INC", {OP_INC,1}},
   {"DEC", {OP_DEC,1}},
   {"PUSH", {OP_PUSH,1}},
   {"POP", {OP_POP,1}},
   {"BAND", {OP_BAND,2}},
   {"HOST", {OP_HOST,0}},
   {"VPUSH", {OP_VPUSH,2}},
   {"VPOP", {OP_VPOP,2}},
   {"CALL", {OP_CALL,1}}, // labelref
   {"RET", {OP_RET,1}},
   {"JF",{OP_JF,2}},      // 1 + labelref
   {"JT",{OP_JT,2}},      // 1 + labelref
   {"EQ", {OP_EQ,2}},
   {"NE", {OP_NE,2}},
   {"GT", {OP_GT,2}},
   {"LT", {OP_LT,2}},
   {"GE", {OP_GE,2}},
   {"LE", {OP_LE,2}}
};

// every location in the code that referenced a label
std::map<std::string, std::vector<uint64_t>> labelRefs;

// where we found a label defined
std::map<std::string, uint64_t> labelLoc;

bool isJump(const uint8_t opcode) {
   return
      (opcode == OP_JMP)  ||
      (opcode == OP_CALL) ||
      (opcode == OP_JT)   ||
      (opcode == OP_JF);
}

bool isNumeric(const std::string &str) {
   if (str.empty())
      return false;

   // check if the string is a decimal or hex number
   char *endptr;
   (void)strtol(str.c_str(), &endptr, 0);
   return (*endptr == '\0');
}

bool isLabel(const std::string &str) {
   return str.back() == ':';
}

int countUsedBytes(uint64_t value) {
   int count = 1;
   for (int i = sizeof(value) - 1; i >= 0; --i) {
      uint8_t byte = (value >> (i * 8)) & 0xFF;
      if (byte != 0) {
         count = i + 1;  // one-based index
         break;
      }
   }
   return count;
}

void writeBinary(const std::string &inputFilename, const std::string &outputFilename) {
   std::ifstream inputFile(inputFilename);
   std::ofstream outputFile(outputFilename, std::ios::binary);

   if (!inputFile.is_open()) {
      std::cerr << "Error opening file: " << inputFilename << std::endl;
      return;
   }

   if (!outputFile.is_open()) {
      std::cerr << "Error opening file: " << outputFilename << std::endl;
      return;
   }

   std::string line;
   uint64_t pc = 0;

   int expected = 0; // expected operands; if 0, expects opcode
   int expected_label_distance = 0; // if > 0, expects label sometime, == 1 expected now, == 2 expected after current operand
   uint8_t opcode = 0; // last opcode parsed

   // first pass: process labels and generate binary code
   while (std::getline(inputFile, line)) {

      if (expected != 0) {
         std::cerr << "ERROR: new line started with pending expected operands: " << expected << std::endl;
         exit(1);
      }
      if (expected_label_distance > 0) { // never happens
         std::cerr << "ERROR: new line started with pending expected label distance " << expected_label_distance << std::endl;
         exit(1);
      }

      std::istringstream iss(line);
      std::string token;
      while (iss >> token) {
         if (token[0] == ';') {
            break; // ignore comments
         }
         if (isNumeric(token) || token[0] == '@') {
            if (expected <= 0) {
               std::cerr << "ERROR: unexpected operand: " << token << std::endl;
               exit(1);
            }
            if (expected_label_distance == 1) {
               std::cerr << "ERROR: unexpected numeric operand where label was expected: " << token << std::endl;
               exit(1);
            }
            --expected;

            // get closer to the label
            if (expected_label_distance > 0)
               --expected_label_distance;

            // operand: write the numeric value or register index to the binary file
            uint64_t value;
            bool ispointer;
            bool isshort = false;
            if (isNumeric(token)) {
               value = std::stoull(token, nullptr, 0);
               ispointer = false;
            } else {
               // remove the '@' symbol and convert the rest to a numeric value
               std::string ntoken = token.substr(1);
               if (! isNumeric(ntoken)) {
                  std::cerr << "ERROR: @ is not number: " << ntoken << std::endl;
                  exit(1);
               }
               value = std::stoull(ntoken, nullptr, 0);
               ispointer = true;
            }

            int bytecount = countUsedBytes(value);

            uint8_t control;
            if (value <= MAX_SHORT_VAL) {
               // short value encoding
               control = value;
               control |= SHORT_VAL;
               isshort = true;
            } else {
               control = bytecount;
            }

            if (ispointer)
               control |= REG_PTR;

            outputFile.write(reinterpret_cast<const char *>(&control), sizeof(control)); // control byte (1 byte)
            pc += sizeof(control);

            if (! isshort) { // if short, the operand was taken care of by the control byte
               // write operand bytes
               outputFile.write(reinterpret_cast<const char *>(&value), bytecount); // little endian everything
               pc += bytecount;
            }
         } else if (isLabel(token)) {
            // labels can be used anywhere; remove the colon from the label
            token.pop_back();
            labelLoc[token] = pc;
         } else {
            // write the opcode to the binary file
            auto opcodeIt = opcodes.find(token);
            if (opcodeIt != opcodes.end()) {

               if (expected != 0) {
                  std::cerr << "ERROR: unexpected opcode: " << token << std::endl;
                  exit(1);
               }

               opcode = opcodeIt->second.first;
               expected = opcodeIt->second.second;
               if (isJump(opcode)) {
                  expected_label_distance = expected; // the label is the last operand of the jump operation
               }

               outputFile.write(reinterpret_cast<const char *>(&opcode), sizeof(opcode));
               pc += sizeof(opcode);

            } else {
               // assume it is a label reference

               if (expected <= 0 || expected_label_distance != 1) {
                  std::cerr << "ERROR: unexpected possible label reference: " << token << std::endl;
                  exit(1);
               }
               --expected;
               expected_label_distance = 0;

               // write the placeholder reference in the code

               // the VM expects a special operand with a hardcoded (implicit) control==2 byte for jump labels (i.e. uint16_t literal constant)
               // pointless to do relative jumps, shortjump vs. longjump; can't do anything with 1 byte, can do everything with 2 bytes; done.

               // save the label reference for later resolution
               labelRefs[token].push_back(pc);

               // actual 16-bit uint label destination
               uint16_t placeholder = 65535;  // if we fail to fix this, it jumps to the end
               outputFile.write(reinterpret_cast<const char *>(&placeholder), sizeof(placeholder));
               pc += sizeof(placeholder);
            }
         }
      }
   }

   // second pass: resolve label references
   for (const auto &entry : labelRefs) {
      const std::string &label = entry.first;
      const uint64_t labelAddress = labelLoc[label];

      if (labelAddress > 65535) {
         std::cerr << "ERROR: program too large (>65535 code bytes) for location of label: " << label << std::endl;
         exit(1);
      }

      uint16_t laddr = (uint16_t)labelAddress;

      for (uint64_t pcLocation : entry.second) {

         // seek to the correct position in the binary file and overwrite the placeholder with the real label address
         outputFile.seekp(pcLocation, std::ios::beg);
         outputFile.write(reinterpret_cast<const char *>(&laddr), sizeof(laddr));
      }
   }

   inputFile.close();
   outputFile.close();
}

int main(int argc, char *argv[]) {
   std::string inputFilename;
   std::string outputFilename;

   if (argc != 3) {

      if (argc == 2) {
         inputFilename = argv[1];

         // find the position of the last dot (.) in the input filename
         size_t lastDotPosition = inputFilename.find_last_of('.');

         // if a dot is found, remove the extension; otherwise, use the whole filename
         if (lastDotPosition != std::string::npos) {
            outputFilename = inputFilename.substr(0, lastDotPosition) + ".b";
            if (outputFilename == inputFilename) {
               outputFilename = inputFilename + ".b";
            }
         } else {
            // if no dot is found, simply append ".b" to the input filename
            outputFilename = inputFilename + ".b";
         }
      } else {
         std::cerr << "Usage: " << argv[0] << " <input_filename> [output_filename]" << std::endl;
         return 1;
      }
   } else {
      inputFilename = argv[1];
      outputFilename = argv[2];
   }

   writeBinary(inputFilename, outputFilename);

   return 0;
}
