/*
  GASM

  Assembler for the GVM.

  GASM takes two arguments: an input filename and an output filename.

  The input file must conform to the GASM language.

  The output file is the generated bytecode that can be sent as input to the GVM.

  If output filename is ommitted, will use input filename with a ".b" extension.

  TODO:

  - nested control macros (if/else/end/while/repeat)

  - better REGEXPs for the macros (spaces...)

  - #include "xxx.h" macro

  - parse simple C constant declarations
    - enum {
    NAME = VALUE_OR_NAME ;
    };
    - const uint64_t NAME = VALUE_OR_NAME ;

  - Ensure GASM does not tolerate any invalid input
    (for example, check for ISTACK/OSTACK set on opcodes that don't support it)

*/

#include "gvm.hpp"

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <cstring>
#include <regex>

#include "expr.hpp"

// opcode string --> pair< opcode code, opcode num-operands  >
std::map<std::string, std::pair<uint8_t, uint8_t>> opcodes = {
   {"NOP", {OP_NOP,0}},
   {"TERM", {OP_TERM,0}},
   {"SET", {OP_SET,2}},
   {"JMP", {OP_JMP,1}},   // labelref
   {"ADD", {OP_ADD,2}},
   {"SUB", {OP_SUB,2}},
   {"MUL", {OP_MUL,2}},
   {"DIV", {OP_DIV,2}},
   {"MOD", {OP_MOD,2}},
   {"OR", {OP_OR,2}},
   {"ANDL", {OP_ANDL,2}},
   {"XOR", {OP_XOR,2}},
   {"NOT", {OP_NOT,1}},
   {"SHL", {OP_SHL,2}},
   {"SHR", {OP_SHR,2}},
   {"INC", {OP_INC,1}},
   {"DEC", {OP_DEC,1}},
   {"PUSH", {OP_PUSH,1}},
   {"POP", {OP_POP,1}},
   {"AND", {OP_AND,2}},
   {"HOST", {OP_HOST,0}},
   {"VPUSH", {OP_VPUSH,2}},
   {"VPOP", {OP_VPOP,2}},
   {"CALL", {OP_CALL,1}}, // labelref
   {"RET", {OP_RET,1}},
   {"JF",{OP_JF,2}},      // 1 + labelref
   {"JT",{OP_JT,2}},      // 1 + labelref
   {"EQ", {OP_EQ,2}},
   {"NE", {OP_NE,2}},
   {"GT", {OP_GT,2}},
   {"LT", {OP_LT,2}},
   {"GE", {OP_GE,2}},
   {"LE", {OP_LE,2}},
   {"NEG", {OP_NEG,1}},
   {"ORL", {OP_OR,2}}
};

// every location in the code that referenced a label
std::map<std::string, std::vector<uint64_t>> labelRefs;

// where we found a label defined
std::map<std::string, uint64_t> labelLoc;

bool isJump(const uint8_t opcode) {
   return
      (opcode == OP_JMP)  ||
      (opcode == OP_CALL) ||
      (opcode == OP_JT)   ||
      (opcode == OP_JF);
}

bool isNumeric(const std::string &str) {
   if (str.empty())
      return false;

   // check if the string is a decimal or hex number
   char *endptr;
   (void)strtol(str.c_str(), &endptr, 0);
   return (*endptr == '\0');
}

bool isLabel(const std::string &str) {
   return str.back() == ':';
}

int countUsedBytes(uint64_t value) {
   int count = 1;
   for (int i = sizeof(value) - 1; i >= 0; --i) {
      uint8_t byte = (value >> (i * 8)) & 0xFF;
      if (byte != 0) {
         count = i + 1;  // one-based index
         break;
      }
   }
   return count;
}

void setLastByteToStackOp(const std::string &binaryFilename) {
   // last byte must be an opcode to toggle to stack operation mode (ISTACK = pop operands from stack | OSTACK = push result to stack)
   std::fstream file(binaryFilename, std::ios::in | std::ios::out | std::ios::binary);
   if (!file.is_open()) {
      std::cerr << "Error opening file: " << binaryFilename << std::endl;
      exit(1);
   }
   file.seekg(-1, std::ios::end);
   char lastByte;
   file.read(&lastByte, 1);
   lastByte |= OP_ISTACK;
   lastByte |= OP_OSTACK;
   file.seekp(-1, std::ios::end);
   file.write(&lastByte, 1);
   file.close();
}

void writeBinary(const std::string &inputFilename, const std::string &outputFilename) {
   std::ifstream inputFile(inputFilename);
   std::ofstream outputFile(outputFilename, std::ios::binary);
   outputFile << std::unitbuf;

   if (!inputFile.is_open()) {
      std::cerr << "Error opening file: " << inputFilename << std::endl;
      return;
   }

   if (!outputFile.is_open()) {
      std::cerr << "Error opening file: " << outputFilename << std::endl;
      return;
   }

   std::string line;
   uint64_t pc = 0;

   int expected = 0; // expected operands; if 0, expects opcode
   int expected_label_distance = 0; // if > 0, expects label sometime, == 1 expected now, == 2 expected after current operand
   uint8_t opcode = 0; // last opcode parsed

   // just to declare the last-parsed-opcode iterator
   auto opcodeIt = opcodes.find("NOP");

   // FIXME/TODO: need to create a stack of these contexts
   //
   // global parsing macro state
   bool macro_if = false;   // inside if
   bool macro_else = false;  // inside else branch of if
   bool macro_while = false; // inside while

   int macro_label = 0; // label generator for if/while jumping

   int macro_label_if_end;    // at the end of the true case, jump here
   int macro_label_if_false;  // in case of false, jump to this

   int macro_label_while_start;  // start of the while loop, where the expression is (re)evaluated
   int macro_label_while_end;  // end of the while loop ("REPEAT")

   // first pass: process labels and generate binary code
   while (std::getline(inputFile, line)) {

      if (expected != 0) {
         if (opcodeIt->second.second == expected) {
            //std::cout << "line start" << std::endl;
            setLastByteToStackOp(outputFilename);
            expected = 0;
         } else {
            std::cerr << "ERROR: new line started with pending expected operands: " << expected << " (original expected: " << opcodeIt->second.second << ")" << std::endl;
            exit(1);
         }
      }

      if (expected_label_distance > 0) { // never happens
         std::cerr << "ERROR: new line started with pending expected label distance " << expected_label_distance << std::endl;
         exit(1);
      }

      // -----------------------------------------------------------------------
      // before doing the regular token loop in this line, check for macros
      // -----------------------------------------------------------------------

      bool macro = false;

      // MACRO: @# = <expression>
      if (!macro) {
         std::regex pattern("@(\\d+) = (.*)");
         std::smatch matches;
         if (std::regex_match(line, matches, pattern)) {
            //std::cout << "reg#: " << matches[1].str() << std::endl;
            //std::cout << "expr: " << matches[2].str() << std::endl;

            std::string regNum = matches[1].str();
            std::string exprProg = expressionToGASM(matches[2].str(), false);

            std::ostringstream oss;
            oss << exprProg;

            // TODO: this could generate smaller bytecode with OP_SET | OP_ISTACK support:
            //       (may be true for the other expression parsers below)

            // result of exprProg in the stack, so pop it into the desired register
            oss << "POP " << regNum << " ";

            line = oss.str();
            macro = true;
         }
      }

      // MACRO: = <expression>
      if (!macro) {
         std::regex pattern("= (.*)");
         std::smatch matches;
         if (std::regex_match(line, matches, pattern)) {
            //std::cout << "expr: " << matches[1].str() << std::endl;

            //"= <expr>" is just the program; result value is pushed into the stack
            line = expressionToGASM(matches[1].str(), false);

            macro = true;
         }
      }

      // MACRO: IF
      if (!macro) {

         std::regex pattern("IF (.*)");
         std::smatch matches;
         if (std::regex_match(line, matches, pattern)) {

            // TODO: nesting support
            if (macro_if || macro_else || macro_while) {
               std::cerr << "ERROR: nested if "<< std::endl;
               exit(1);
            }
            macro_if = true;

            //std::cout << "IF" << std::endl;
            //std::cout << "expr: " << matches[1].str() << std::endl;

            std::string exprProg = expressionToGASM(matches[1].str(), false);

            std::ostringstream oss;

            macro_label_if_false = macro_label++;
            macro_label_if_end = macro_label++;

            // first we compute the expression, leaving the true/false value in the stack
            oss << exprProg;

            // pop expr result and jump to the false location (label; we'll figure out where it is later)
            oss << "JF __IF_" << macro_label_if_false << " ";

            line = oss.str();
            macro = true;
         }
      }

      // MACRO: ELSE
      if (!macro) {
         std::regex pattern("ELSE");
         std::smatch matches;
         if (std::regex_match(line, matches, pattern)) {

            // TODO: nesting support
            if (!macro_if || macro_else || macro_while) {
               std::cerr << "ERROR: misplaced ELSE "<< std::endl;
               exit(1);
            }
            macro_if = false;
            macro_else = true;

            //std::cout << "ELSE" << std::endl;

            std::ostringstream oss;

            // jump the true case to the end
            oss << "JMP __IF_" << macro_label_if_end << " ";

            // write the false label destination
            oss << "__IF_" << macro_label_if_false << ": ";

            line = oss.str();
            macro = true;
         }
      }

      // MACRO: END
      if (!macro) {
         std::regex pattern("END");
         std::smatch matches;
         if (std::regex_match(line, matches, pattern)) {

            // TODO: nesting support
            if (macro_if && macro_else) {
               std::cerr << "ERROR: IF and ELSE active at same time" << std::endl;
               exit(1);
            }
            if ((!macro_if && !macro_else) || macro_while) {
               std::cerr << "ERROR: misplaced END"<< std::endl;
               exit(1);
            }

            //std::cout << "END" << std::endl;

            std::ostringstream oss;

            if (macro_if) {
               // if end
               // write the false label destination since no else
               oss << "__IF_" << macro_label_if_false << ": ";
            } else {
               // else end
               // write the end label destination (only needed for if else end case)
               oss << "__IF_" << macro_label_if_end << ": ";
            }

            line = oss.str();
            macro = true;

            macro_if = false;
            macro_else = false;
         }
      }

      // MACRO: WHILE
      if (!macro) {
         std::regex pattern("WHILE (.*)");
         std::smatch matches;
         if (std::regex_match(line, matches, pattern)) {

            // TODO: nesting support
            if (macro_if || macro_else || macro_while) {
               std::cerr << "ERROR: nested while "<< std::endl;
               exit(1);
            }
            macro_while = true;

            //std::cout << "WHILE" << std::endl;
            //std::cout << "expr: " << matches[1].str() << std::endl;

            std::string exprProg = expressionToGASM(matches[1].str(), false);

            std::ostringstream oss;

            macro_label_while_start = macro_label++;
            macro_label_while_end = macro_label++;

            // drop the label where we will go back to on REPEAT
            oss << "__WHILE_" << macro_label_while_start << ": ";

            // first we compute the expression, leaving the true/false value in the stack
            oss << exprProg;

            // pop expr result and jump to the false location (label; we'll figure out where it is later)
            oss << "JF __WHILE_" << macro_label_while_end << " ";

            line = oss.str();
            macro = true;
         }
      }

      // MACRO: REPEAT
      if (!macro) {
         std::regex pattern("REPEAT");
         std::smatch matches;
         if (std::regex_match(line, matches, pattern)) {

            // TODO: nesting support
            if (macro_if || macro_else || !macro_while) {
               std::cerr << "ERROR: misplaced REPEAT"<< std::endl;
               exit(1);
            }
            macro_while = false;

            //std::cout << "REPEAT" << std::endl;

            std::ostringstream oss;

            // jump to the expression re-evaluation point
            oss << "JMP __WHILE_" << macro_label_while_start << " ";

            // drop the end of while label
            oss << "__WHILE_" << macro_label_while_end << ": ";

            line = oss.str();
            macro = true;
         }

      }

      if (macro) {
         //std::cout << "Macro: " << line << std::endl;
      }

      // -----------------------------------------------------------------------
      // regular line tokenization (opcodes, operands, labels)
      // -----------------------------------------------------------------------

      std::istringstream iss(line);
      std::string token;
      while (iss >> token) {
         if (token[0] == ';') {
            break; // ignore comments
         }
         if (isNumeric(token) || token[0] == '@') {

            if (expected_label_distance == 1) {
               std::cerr << "ERROR: unexpected numeric operand where label was expected: " << token << std::endl;
               exit(1);
            }

            if (expected <= 0) {
               std::cerr << "ERROR: unexpected operand: " << token << std::endl;
               exit(1);
            }

            --expected;

            // get closer to the label
            if (expected_label_distance > 0)
               --expected_label_distance;

            // operand: write the numeric value or register index to the binary file
            uint64_t value;
            bool ispointer;
            bool isshort = false;
            if (isNumeric(token)) {
               value = std::stoull(token, nullptr, 0);
               ispointer = false;
            } else {
               // remove the '@' symbol and convert the rest to a numeric value
               std::string ntoken = token.substr(1);
               if (! isNumeric(ntoken)) {
                  std::cerr << "ERROR: @ is not number: " << ntoken << std::endl;
                  exit(1);
               }
               value = std::stoull(ntoken, nullptr, 0);
               ispointer = true;
            }

            int bytecount = countUsedBytes(value);

            uint8_t control;
            if (value <= MAX_SHORT_VAL) {
               // short value encoding
               control = value;
               control |= SHORT_VAL;
               isshort = true;
            } else {
               control = bytecount;
            }

            if (ispointer)
               control |= REG_PTR;

            outputFile.write(reinterpret_cast<const char *>(&control), sizeof(control)); // control byte (1 byte)
            pc += sizeof(control);

            if (! isshort) { // if short, the operand was taken care of by the control byte
               // write operand bytes
               outputFile.write(reinterpret_cast<const char *>(&value), bytecount); // little endian everything
               pc += bytecount;
            }
         } else if (isLabel(token)) {
            // labels can be used anywhere; remove the colon from the label
            token.pop_back();
            labelLoc[token] = pc;
         } else {
            // write the opcode to the binary file
            auto prevOpcodeIt = opcodeIt;
            opcodeIt = opcodes.find(token);
            if (opcodeIt != opcodes.end()) {

               if (expected != 0) {
                  if (prevOpcodeIt->second.second == expected) {
                     //std::cout << "opcode start" << std::endl;
                     setLastByteToStackOp(outputFilename);
                     expected = 0;
                  } else {
                     std::cerr << "ERROR: started new opcode " << token << " with pending expected operands: " << expected << " (original expected: " << prevOpcodeIt->second.second << ")" << std::endl;
                     exit(1);
                  }
               }

               opcode = opcodeIt->second.first;
               expected = opcodeIt->second.second;
               if (isJump(opcode)) {
                  expected_label_distance = expected; // the label is the last operand of the jump operation
               }

               outputFile.write(reinterpret_cast<const char *>(&opcode), sizeof(opcode));
               pc += sizeof(opcode);

            } else {
               // assume it is a label reference

               if (expected <= 0 || expected_label_distance != 1) {

                  // STACK CASE: JF/JT stack version, with the value to test taken from the stack,
                  //             so we find the label immediately
                  //
                  //TODO: may need to write better code here if we create different jump opcodes with different quantities/order of non-label operands
                  //
                  if (expected > 0 && expected_label_distance == 2) {

                     // it's from the stack, so don't expect the operand
                     --expected;

                     // tag as both ISTACK and OSTACK (fine for now)
                     setLastByteToStackOp(outputFilename);

                  } else {
                     std::cerr << "ERROR: unexpected possible label reference: " << token << std::endl;
                     exit(1);
                  }
               }
               --expected;
               expected_label_distance = 0;

               // write the placeholder reference in the code

               // the VM expects a special operand with a hardcoded (implicit) control==2 byte for jump labels (i.e. uint16_t literal constant)
               // pointless to do relative jumps, shortjump vs. longjump; can't do anything with 1 byte, can do everything with 2 bytes; done.

               // save the label reference for later resolution
               labelRefs[token].push_back(pc);

               // actual 16-bit uint label destination
               uint16_t placeholder = 65535;  // if we fail to fix this, it jumps to the end
               outputFile.write(reinterpret_cast<const char *>(&placeholder), sizeof(placeholder));
               pc += sizeof(placeholder);
            }
         }
      }
   }

   // check for pending expected stuff after all lines
   if (expected != 0) {
      if (opcodeIt->second.second == expected) {
         //std::cout << "file end" << std::endl;
         setLastByteToStackOp(outputFilename);
         expected = 0;
      } else {
         std::cerr << "ERROR: input file ended with pending expected operands: " << expected << " (original expected: " << opcodeIt->second.second << ")" << std::endl;
         exit(1);
      }
   }

   // second pass: resolve label references
   for (const auto &entry : labelRefs) {
      const std::string &label = entry.first;
      const uint64_t labelAddress = labelLoc[label];

      if (labelAddress > 65535) {
         std::cerr << "ERROR: program too large (>65535 code bytes) for location of label: " << label << std::endl;
         exit(1);
      }

      uint16_t laddr = (uint16_t)labelAddress;

      for (uint64_t pcLocation : entry.second) {

         // seek to the correct position in the binary file and overwrite the placeholder with the real label address
         outputFile.seekp(pcLocation, std::ios::beg);
         outputFile.write(reinterpret_cast<const char *>(&laddr), sizeof(laddr));
      }
   }

   inputFile.close();
   outputFile.close();
}

int main(int argc, char *argv[]) {
   std::string inputFilename;
   std::string outputFilename;

   if (argc != 3) {

      if (argc == 2) {
         inputFilename = argv[1];

         // find the position of the last dot (.) in the input filename
         size_t lastDotPosition = inputFilename.find_last_of('.');

         // if a dot is found, remove the extension; otherwise, use the whole filename
         if (lastDotPosition != std::string::npos) {
            outputFilename = inputFilename.substr(0, lastDotPosition) + ".b";
            if (outputFilename == inputFilename) {
               outputFilename = inputFilename + ".b";
            }
         } else {
            // if no dot is found, simply append ".b" to the input filename
            outputFilename = inputFilename + ".b";
         }
      } else {
         std::cerr << "Usage: " << argv[0] << " <input_filename> [output_filename]" << std::endl;
         return 1;
      }
   } else {
      inputFilename = argv[1];
      outputFilename = argv[2];
   }

   writeBinary(inputFilename, outputFilename);

   return 0;
}
